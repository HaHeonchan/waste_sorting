/**
 * Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ïª®Ìä∏Î°§Îü¨ - ÏµúÏ†ÅÌôî Î≤ÑÏ†Ñ
 * Ïì∞Î†àÍ∏∞ Î∂ÑÎ•òÎ•º ÏúÑÌïú Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Î∞è Î∂ÑÏÑù Í∏∞Îä•
 */

const OpenAI = require('openai');
const multer = require('multer');
const fs = require('fs');
const path = require('path');

// ÎÇ¥Î∂Ä Î™®Îìà import
const { 
    TEXT_BASED_ANALYSIS_PROMPT, 
    COMPREHENSIVE_ANALYSIS_PROMPT,
    DIRECT_IMAGE_ANALYSIS_PROMPT,
    OBJECT_BASED_ANALYSIS_PROMPT,
    LABEL_BASED_ANALYSIS_PROMPT
} = require('./prompts');
const { 
    analyzeImageWithLogoDetection,
    analyzeRecyclingMarksWithObjectsAndLabels,
    performComprehensiveVisionAnalysis
} = require('./logo-detector');

// OpenAI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
});

// Multer ÏÑ§Ï†ï
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadDir = 'uploads/';
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + '-' + file.originalname);
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
    fileFilter: (req, file, cb) => {
        file.mimetype.startsWith('image/') ? cb(null, true) : cb(new Error('Ïù¥ÎØ∏ÏßÄ ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.'), false);
    }
});

// Ïª®Ìä∏Î°§Îü¨ Í∞ùÏ≤¥
const analyzeController = {
    // Î∂ÑÏÑù ÌéòÏù¥ÏßÄ Î†åÎçîÎßÅ
    renderAnalyzePage: (req, res) => {
        res.render('analyze/waste-sorting');
    },

    // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Î∞è Î∂ÑÏÑù Ï≤òÎ¶¨
    uploadAndAnalyzeImage: async (req, res) => {
        console.log('üöÄ Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÏöîÏ≤≠ ÏãúÏûë');
        
        try {
            upload.single('image')(req, res, async (err) => {
                if (err) {
                    return res.status(400).json({ error: 'ÌååÏùº ÏóÖÎ°úÎìú Ïã§Ìå®', details: err.message });
                }

                if (!req.file) {
                    return res.status(400).json({ error: 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.' });
                }

                try {
                    // Î∂ÑÏÑù Ïã§Ìñâ
                    const result = await performAnalysis(req.file.path);
                    
                    res.json(result);
                    
                } catch (analysisError) {
                    res.status(500).json({ 
                        error: 'Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
                        details: analysisError.message 
                    });
                } finally {
                    // ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
                    cleanupFile(req.file.path);
                }
            });
        } catch (error) {
            res.status(500).json({ error: 'ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', details: error.message });
        }
    },

    // Í∞úÏÑ†Îêú Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Î∞è Î∂ÑÏÑù Ï≤òÎ¶¨ (Í∞ùÏ≤¥/ÎùºÎ≤® Ìè¨Ìï®)
    uploadAndAnalyzeImageComprehensive: async (req, res) => {
        console.log('üöÄ Í∞úÏÑ†Îêú Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÏöîÏ≤≠ ÏãúÏûë (Í∞ùÏ≤¥/ÎùºÎ≤® Ìè¨Ìï®)');
        
        try {
            upload.single('image')(req, res, async (err) => {
                if (err) {
                    return res.status(400).json({ error: 'ÌååÏùº ÏóÖÎ°úÎìú Ïã§Ìå®', details: err.message });
                }

                if (!req.file) {
                    return res.status(400).json({ error: 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.' });
                }

                try {
                    // Í∞úÏÑ†Îêú Î∂ÑÏÑù Ïã§Ìñâ
                    const result = await performComprehensiveAnalysis(req.file.path);
                    
                    res.json(result);
                    
                } catch (analysisError) {
                    res.status(500).json({ 
                        error: 'Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
                        details: analysisError.message 
                    });
                } finally {
                    // ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
                    cleanupFile(req.file.path);
                }
            });
        } catch (error) {
            res.status(500).json({ error: 'ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', details: error.message });
        }
    }
};

// Í∏∞Ï°¥ Î∂ÑÏÑù ÏàòÌñâ Ìï®Ïàò
async function performAnalysis(imagePath) {
    console.log('üîç Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÏãúÏûë...');
    
    // Google Vision APIÎ°ú ÌÖçÏä§Ìä∏ Î∂ÑÏÑù
    const textAnalysis = await analyzeImageWithLogoDetection(imagePath);
    
    // Î∂ÑÏÑù Î∞©Î≤ï Í≤∞Ï†ï Î∞è Ïã§Ìñâ
    const hasRecyclingContent = textAnalysis.hasRecyclingMarks && 
                               textAnalysis.logoDetection && 
                               (textAnalysis.logoDetection.recyclingTexts.length > 0 || 
                                textAnalysis.logoDetection.recyclingMarks.length > 0);
    
    let finalAnalysis;
    if (hasRecyclingContent) {
        console.log('üìù ÌÖçÏä§Ìä∏ Í∏∞Î∞ò Î∂ÑÏÑù Ïã§Ìñâ');
        finalAnalysis = await analyzeWithTextResults(textAnalysis);
    } else {
        console.log('üñºÔ∏è Ïù¥ÎØ∏ÏßÄ ÏßÅÏ†ë Î∂ÑÏÑù Ïã§Ìñâ');
        finalAnalysis = await analyzeImageDirectly(imagePath);
    }
    
    return {
        type: finalAnalysis.analysis.wasteType,
        detail: finalAnalysis.analysis.subType,
        mark: finalAnalysis.analysis.recyclingMark,
        description: finalAnalysis.analysis.description,
        method: finalAnalysis.analysis.disposalMethod,
        model: finalAnalysis.model,
        token_usage: finalAnalysis.usage?.total_tokens || 0,
        analysis_type: finalAnalysis.analysisType || "text_based"
    };
}

// Í∞úÏÑ†Îêú Î∂ÑÏÑù ÏàòÌñâ Ìï®Ïàò (Í∞ùÏ≤¥/ÎùºÎ≤® Ìè¨Ìï®)
async function performComprehensiveAnalysis(imagePath) {
    console.log('üîç Í∞úÏÑ†Îêú Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÏãúÏûë (Í∞ùÏ≤¥/ÎùºÎ≤® Ìè¨Ìï®)...');
    
    // ÌÜµÌï© Vision API Î∂ÑÏÑù Ïã§Ìñâ
    const comprehensiveAnalysis = await analyzeRecyclingMarksWithObjectsAndLabels(imagePath);
    
    // Î∂ÑÏÑù Î∞©Î≤ï Í≤∞Ï†ï Î∞è Ïã§Ìñâ
    const hasRecyclingContent = comprehensiveAnalysis.recyclingMarks.length > 0 ||
                               comprehensiveAnalysis.recyclingObjects?.length > 0 ||
                               comprehensiveAnalysis.recyclingLabels?.length > 0;
    
    let finalAnalysis;
    if (hasRecyclingContent) {
        console.log('üìù ÌÜµÌï© Î∂ÑÏÑù Ïã§Ìñâ (ÌÖçÏä§Ìä∏ + Í∞ùÏ≤¥ + ÎùºÎ≤®)');
        finalAnalysis = await analyzeWithComprehensiveResults(comprehensiveAnalysis);
    } else {
        console.log('üñºÔ∏è Ïù¥ÎØ∏ÏßÄ ÏßÅÏ†ë Î∂ÑÏÑù Ïã§Ìñâ');
        finalAnalysis = await analyzeImageDirectly(imagePath);
    }
    
    return {
        type: finalAnalysis.analysis.wasteType,
        detail: finalAnalysis.analysis.subType,
        mark: finalAnalysis.analysis.recyclingMark,
        description: finalAnalysis.analysis.description,
        method: finalAnalysis.analysis.disposalMethod,
        model: finalAnalysis.model,
        token_usage: finalAnalysis.usage?.total_tokens || 0,
        analysis_type: finalAnalysis.analysisType || "comprehensive",
        confidence: comprehensiveAnalysis.confidence || 0,
        analysis_details: finalAnalysis.analysis.analysisDetails || null
    };
}

// ÌÖçÏä§Ìä∏ Í∏∞Î∞ò Î∂ÑÏÑù
async function analyzeWithTextResults(textAnalysisResults) {
    const prompt = TEXT_BASED_ANALYSIS_PROMPT.replace(
        '{textAnalysisResults}',
        JSON.stringify(textAnalysisResults, null, 2)
    );
    
    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 300
    });

    return {
        analysis: parseGPTResponse(response.choices[0].message.content),
        model: response.model,
        usage: response.usage,
        analysisType: "text_based"
    };
}

// ÌÜµÌï© Î∂ÑÏÑù (ÌÖçÏä§Ìä∏ + Í∞ùÏ≤¥ + ÎùºÎ≤®)
async function analyzeWithComprehensiveResults(comprehensiveResults) {
    // ÌÖçÏä§Ìä∏ Î∂ÑÏÑù Í≤∞Í≥º Ìè¨Îß∑ÌåÖ
    const textAnalysisResults = {
        hasRecyclingMarks: comprehensiveResults.recyclingMarks.length > 0,
        recyclingTexts: comprehensiveResults.recyclingTexts || [],
        recyclingMarks: comprehensiveResults.recyclingMarks || [],
        complexAnalysis: comprehensiveResults.complexAnalysis || [],
        confidence: comprehensiveResults.confidence || 0,
        summary: comprehensiveResults.summary || ''
    };

    // Í∞ùÏ≤¥ Î∂ÑÏÑù Í≤∞Í≥º Ìè¨Îß∑ÌåÖ
    const objectAnalysisResults = comprehensiveResults.recyclingObjects?.map(obj => ({
        name: obj.name,
        confidence: obj.score,
        description: `${obj.name} (Ïã†Î¢∞ÎèÑ: ${Math.round(obj.score * 100)}%)`
    })) || [];

    // ÎùºÎ≤® Î∂ÑÏÑù Í≤∞Í≥º Ìè¨Îß∑ÌåÖ
    const labelAnalysisResults = comprehensiveResults.recyclingLabels?.map(label => ({
        name: label.description,
        confidence: label.score,
        description: `${label.description} (Ïã†Î¢∞ÎèÑ: ${Math.round(label.score * 100)}%)`
    })) || [];

    // Î°úÍ≥† Î∂ÑÏÑù Í≤∞Í≥º Ìè¨Îß∑ÌåÖ
    const logoAnalysisResults = comprehensiveResults.logos?.map(logo => ({
        name: logo.description,
        confidence: logo.score || 0.8,
        description: `${logo.description} (Ïã†Î¢∞ÎèÑ: ${Math.round((logo.score || 0.8) * 100)}%)`
    })) || [];

    const prompt = COMPREHENSIVE_ANALYSIS_PROMPT
        .replace('{textAnalysisResults}', JSON.stringify(textAnalysisResults, null, 2))
        .replace('{objectAnalysisResults}', JSON.stringify(objectAnalysisResults, null, 2))
        .replace('{labelAnalysisResults}', JSON.stringify(labelAnalysisResults, null, 2))
        .replace('{logoAnalysisResults}', JSON.stringify(logoAnalysisResults, null, 2));
    
    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 500
    });

    return {
        analysis: parseGPTResponse(response.choices[0].message.content),
        model: response.model,
        usage: response.usage,
        analysisType: "comprehensive"
    };
}

// Í∞ùÏ≤¥ Í∏∞Î∞ò Î∂ÑÏÑù
async function analyzeWithObjectResults(objectResults) {
    const objectAnalysisResults = objectResults.map(obj => ({
        name: obj.name,
        confidence: obj.score,
        description: `${obj.name} (Ïã†Î¢∞ÎèÑ: ${Math.round(obj.score * 100)}%)`
    }));

    const objectConfidenceResults = objectResults.map(obj => 
        `${obj.name}: ${Math.round(obj.score * 100)}%`
    ).join(', ');

    const prompt = OBJECT_BASED_ANALYSIS_PROMPT
        .replace('{objectAnalysisResults}', JSON.stringify(objectAnalysisResults, null, 2))
        .replace('{objectConfidenceResults}', objectConfidenceResults);
    
    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 300
    });

    return {
        analysis: parseGPTResponse(response.choices[0].message.content),
        model: response.model,
        usage: response.usage,
        analysisType: "object_based"
    };
}

// ÎùºÎ≤® Í∏∞Î∞ò Î∂ÑÏÑù
async function analyzeWithLabelResults(labelResults) {
    const labelAnalysisResults = labelResults.map(label => ({
        name: label.description,
        confidence: label.score,
        description: `${label.description} (Ïã†Î¢∞ÎèÑ: ${Math.round(label.score * 100)}%)`
    }));

    const labelConfidenceResults = labelResults.map(label => 
        `${label.description}: ${Math.round(label.score * 100)}%`
    ).join(', ');

    const prompt = LABEL_BASED_ANALYSIS_PROMPT
        .replace('{labelAnalysisResults}', JSON.stringify(labelAnalysisResults, null, 2))
        .replace('{labelConfidenceResults}', labelConfidenceResults);
    
    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 300
    });

    return {
        analysis: parseGPTResponse(response.choices[0].message.content),
        model: response.model,
        usage: response.usage,
        analysisType: "label_based"
    };
}

// Ïù¥ÎØ∏ÏßÄ ÏßÅÏ†ë Î∂ÑÏÑù
async function analyzeImageDirectly(imagePath) {
    const imageBuffer = fs.readFileSync(imagePath);
    const base64Image = imageBuffer.toString('base64');
    
    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
            {
                role: "user",
                content: [
                    { type: "text", text: DIRECT_IMAGE_ANALYSIS_PROMPT },
                    {
                        type: "image_url",
                        image_url: { url: `data:image/jpeg;base64,${base64Image}` }
                    }
                ]
            }
        ],
        max_tokens: 300
    });

    return {
        analysis: parseGPTResponse(response.choices[0].message.content),
        model: response.model,
        usage: response.usage,
        analysisType: "direct_image"
    };
}

// GPT ÏùëÎãµ ÌååÏã±
function parseGPTResponse(content) {
    try {
        const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/) || 
                         content.match(/\{[\s\S]*\}/);
        const jsonString = jsonMatch ? jsonMatch[1] || jsonMatch[0] : content;
        return JSON.parse(jsonString);
    } catch (parseError) {
        console.error('JSON ÌååÏã± Ïò§Î•ò:', parseError);
        return {
            wasteType: "Î∂ÑÎ•ò Ïã§Ìå®",
            subType: "Ïïå Ïàò ÏóÜÏùå",
            recyclingMark: "Ìï¥ÎãπÏóÜÏùå",
            description: content,
            disposalMethod: "ÌôïÏù∏ ÌïÑÏöî",
            confidence: 0
        };
    }
}

// ÌååÏùº Ï†ïÎ¶¨
function cleanupFile(filePath) {
    if (filePath && fs.existsSync(filePath)) {
        try {
            fs.unlinkSync(filePath);
            console.log('üóëÔ∏è ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨ ÏôÑÎ£å');
        } catch (error) {
            console.error('‚ùå ÌååÏùº Ï†ïÎ¶¨ Ïã§Ìå®:', error);
        }
    }
}

module.exports = analyzeController; 